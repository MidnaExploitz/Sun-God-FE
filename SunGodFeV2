-- SERVICES
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local Debris = game:GetService("Debris")
local lp = Players.LocalPlayer
local camera = workspace.CurrentCamera
-- CONFIG
local ANIMATIONS = {
    idle = "rbxassetid://99638411514722",
    walk = "rbxassetid://127834645809981",
    jump = "rbxassetid://507765000",
    dash = "rbxassetid://110361063508944",
    punch = "rbxassetid://119999999999999",
    charge = "rbxassetid://123200367867450"
}
local WALK_PLAY_SPEED = 1.1
local DASH_FORCE = 140
local DASH_TIME = 0.25
local DASH_COOLDOWN = 2.3
local MAX_DASHES = 3
local DASH_RECHARGE_TIME = 12
local PUNCH_COOLDOWN = 2.3
local LONG_PUNCH_SPEED = 0.3
local chargeLength = 0.91
local crossfadeTime = 0.03
local POWERUP_TIME = 6
local SUN_SIZE = 11
local SUN_COLOR = Color3.fromRGB(255, 165, 0)
local SUN_MATERIAL = Enum.Material.Neon
local SUN_BOB_AMPLITUDE = 2
local SUN_BOB_FREQUENCY = 2
local SUN_SUMMON_TIME = 1.0
local SUN_FIRE_TEXTURE = "rbxasset://textures/particles/fire_main.dds"
-- ORBIT + SWAY + ALIVE SETTINGS
local ORBIT_RADIUS = 18 -- charge orbit distance
local BEHIND_DISTANCE = 13 -- normal idle/return distance (fixed close)
local ORBIT_SPEED = 2.2
local ORBIT_HEIGHT = 7
local ORBIT_BOB_AMP = 2.1
local ORBIT_BOB_FREQ = 2.3
local SWAY_AMP = 1.8
local SWAY_FREQ = 1.1
local SWAY_ROT_SPEED = 0.7
local TRANSITION_TIME = 1.1
local PULSE_MIN = 0.94
local PULSE_MAX = 1.08
local PULSE_SPEED = 1.4
-- ELLIPTICAL ORBIT SETTINGS (during charge)
local ORBIT_ECCENTRICITY = 0.35       -- 0 = circle, 0.3–0.45 feels very moon-like but visible, 0.6+ is comet crazy
local ORBIT_MAJOR_AXIS = ORBIT_RADIUS  -- longest distance direction (semi-major)
local ORBIT_MINOR_AXIS = ORBIT_MAJOR_AXIS * math.sqrt(1 - ORBIT_ECCENTRICITY^2)
local FOCUS_OFFSET = ORBIT_MAJOR_AXIS * ORBIT_ECCENTRICITY  -- distance from geometric center to "Earth" focus
local ELLIPSE_ROTATION = 0             -- you can randomize or animate this later (in radians, e.g. math.rad(45))
-- SOUNDS
local CHARGE_LOOP_SOUND = "rbxassetid://84700238102918"
local CHARGE_RETURN_SOUND = "rbxassetid://74424239140462"
-- STATE
local tracks = {}
local dashOnCooldown = false
local punchOnCooldown = false
local isDashing = false
local isCharging = false
local chargeSoundA, chargeSoundB
local chargeParticles, chargeRingParticles, chargeYellowRingParticles, chargeCentralGlow
local chargeAttachment
local lightningBeams = {}
local sunOrb, sunFireParticles
local sunConnection
local dashCount = MAX_DASHES
local runningConnection, noFallConnection, rechargeConnection
local cameraShakeConnection, characterShakeConnection, jumpConnection
local nextRechargeTime = math.huge
local rechargeInterval = DASH_RECHARGE_TIME / MAX_DASHES
local originalAnchored = false
local originalWalkSpeed = 16
local titleBillboard
-- Toggle states
local sunOrbEnabled = true
local dashTrailEnabled = true
local cameraShakeEnabled = true
local charShakeEnabled = true
-- Sun helpers
local transitionStartTime = 0
local wasChargingLastFrame = false
-- GUI SETUP ──────────────────────────────────────────────────────────────────────
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "CombatGUI"
screenGui.ResetOnSpawn = false
screenGui.Parent = lp:WaitForChild("PlayerGui")
local chargeFrame = Instance.new("Frame", screenGui)
chargeFrame.Size = UDim2.new(0, 400, 0, 35)
chargeFrame.Position = UDim2.new(0.5, -200, 0.85, 0)
chargeFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
chargeFrame.BorderSizePixel = 0
Instance.new("UICorner", chargeFrame).CornerRadius = UDim.new(0, 8)
local chargeStroke = Instance.new("UIStroke", chargeFrame)
chargeStroke.Color = Color3.fromRGB(255, 255, 0)
chargeStroke.Transparency = 0.5
chargeStroke.Thickness = 2
local chargeFill = Instance.new("Frame", chargeFrame)
chargeFill.Size = UDim2.new(0, 0, 1, 0)
chargeFill.BackgroundColor3 = Color3.fromRGB(255, 255, 0)
Instance.new("UICorner", chargeFill).CornerRadius = UDim.new(0, 8)
local chargeGradient = Instance.new("UIGradient", chargeFill)
chargeGradient.Color = ColorSequence.new{
    ColorSequenceKeypoint.new(0, Color3.fromRGB(255,255,0)),
    ColorSequenceKeypoint.new(1, Color3.fromRGB(255,165,0))
}
local chargeLabel = Instance.new("TextLabel", chargeFrame)
chargeLabel.Size = UDim2.new(1,0,1,0)
chargeLabel.BackgroundTransparency = 1
chargeLabel.Text = "Charge"
chargeLabel.TextColor3 = Color3.fromRGB(255,255,255)
chargeLabel.TextStrokeTransparency = 0.8
chargeLabel.Font = Enum.Font.GothamBold
chargeLabel.TextSize = 18
local dashFrame = Instance.new("Frame", screenGui)
dashFrame.Size = UDim2.new(0, 200, 0, 30)
dashFrame.Position = UDim2.new(0.5, -100, 0.8, 0)
dashFrame.BackgroundColor3 = Color3.fromRGB(30,30,30)
dashFrame.BorderSizePixel = 0
Instance.new("UICorner", dashFrame).CornerRadius = UDim.new(0,8)
local dashStroke = Instance.new("UIStroke", dashFrame)
dashStroke.Color = Color3.fromRGB(255,255,0)
dashStroke.Transparency = 0.5
dashStroke.Thickness = 2
local dashFill = Instance.new("Frame", dashFrame)
dashFill.Size = UDim2.new(1,0,1,0)
dashFill.BackgroundColor3 = Color3.fromRGB(255,255,0)
Instance.new("UICorner", dashFill).CornerRadius = UDim.new(0,8)
local dashGradient = Instance.new("UIGradient", dashFill)
dashGradient.Color = ColorSequence.new{
    ColorSequenceKeypoint.new(0, Color3.fromRGB(255,255,0)),
    ColorSequenceKeypoint.new(1, Color3.fromRGB(255,165,0))
}
local dashLabel = Instance.new("TextLabel", dashFrame)
dashLabel.Size = UDim2.new(1,0,1,0)
dashLabel.BackgroundTransparency = 1
dashLabel.Text = "Dashes"
dashLabel.TextColor3 = Color3.fromRGB(255,255,255)
dashLabel.TextStrokeTransparency = 0.8
dashLabel.Font = Enum.Font.GothamBold
dashLabel.TextSize = 18
-- CONTROLS GUI ───────────────────────────────────────────────────────────────────
local controlsGui = Instance.new("ScreenGui")
controlsGui.Name = "ControlsGUI"
controlsGui.ResetOnSpawn = false
controlsGui.Enabled = false
controlsGui.Parent = lp:WaitForChild("PlayerGui")
local controlsFrame = Instance.new("Frame", controlsGui)
controlsFrame.Size = UDim2.new(0, 260, 0, 380)
controlsFrame.Position = UDim2.new(0.5, -130, 0.5, -190)
controlsFrame.BackgroundColor3 = Color3.fromRGB(255, 215, 0)
controlsFrame.BackgroundTransparency = 0.35
controlsFrame.BorderSizePixel = 0
Instance.new("UICorner", controlsFrame).CornerRadius = UDim.new(0, 12)
local controlsStroke = Instance.new("UIStroke", controlsFrame)
controlsStroke.Color = Color3.fromRGB(255, 165, 0)
controlsStroke.Thickness = 2
controlsStroke.Transparency = 0.3
local title = Instance.new("TextLabel", controlsFrame)
title.Size = UDim2.new(1,0,0,45)
title.BackgroundTransparency = 1
title.Text = "Controls & Settings"
title.TextColor3 = Color3.fromRGB(30,30,30)
title.Font = Enum.Font.GothamBold
title.TextSize = 26
title.TextStrokeTransparency = 0.7
local function createToggle(labelText, yPos, initialState, callback)
    local container = Instance.new("Frame", controlsFrame)
    container.Size = UDim2.new(1, -20, 0, 40)
    container.Position = UDim2.new(0, 10, 0, yPos)
    container.BackgroundTransparency = 1
    local lbl = Instance.new("TextLabel", container)
    lbl.Size = UDim2.new(0.65, 0, 1, 0)
    lbl.BackgroundTransparency = 1
    lbl.Text = labelText
    lbl.TextColor3 = Color3.fromRGB(30, 30, 30)
    lbl.Font = Enum.Font.GothamSemibold
    lbl.TextSize = 18
    lbl.TextXAlignment = Enum.TextXAlignment.Left
    local toggleBtn = Instance.new("TextButton", container)
    toggleBtn.Size = UDim2.new(0.3, 0, 0.8, 0)
    toggleBtn.Position = UDim2.new(0.68, 0, 0.1, 0)
    toggleBtn.BackgroundColor3 = initialState and Color3.fromRGB(0, 180, 0) or Color3.fromRGB(180, 0, 0)
    toggleBtn.Text = initialState and "ON" or "OFF"
    toggleBtn.TextColor3 = Color3.new(1,1,1)
    toggleBtn.Font = Enum.Font.GothamBold
    toggleBtn.TextSize = 16
    Instance.new("UICorner", toggleBtn).CornerRadius = UDim.new(0, 8)
    toggleBtn.MouseButton1Click:Connect(function()
        initialState = not initialState
        toggleBtn.BackgroundColor3 = initialState and Color3.fromRGB(0, 180, 0) or Color3.fromRGB(180, 0, 0)
        toggleBtn.Text = initialState and "ON" or "OFF"
        callback(initialState)
    end)
end
createToggle("Sun Orb", 60, sunOrbEnabled, function(state)
    sunOrbEnabled = state
    if sunOrb then
        sunOrb.Transparency = state and 0.2 or 1
        if sunFireParticles then sunFireParticles.Enabled = state end
    end
end)
createToggle("Dash Trail", 110, dashTrailEnabled, function(state)
    dashTrailEnabled = state
end)
createToggle("Camera Shake", 160, cameraShakeEnabled, function(state)
    cameraShakeEnabled = state
end)
createToggle("Character Shake", 210, charShakeEnabled, function(state)
    charShakeEnabled = state
end)
local closeHint = Instance.new("TextLabel", controlsFrame)
closeHint.Size = UDim2.new(1,-20,0,30)
closeHint.Position = UDim2.new(0,10,1,-40)
closeHint.BackgroundTransparency = 1
closeHint.Text = "Press C to open/close"
closeHint.TextColor3 = Color3.fromRGB(60,60,60)
closeHint.Font = Enum.Font.Gotham
closeHint.TextSize = 14
controlsFrame.Active = true
controlsFrame.Draggable = true
UserInputService.InputBegan:Connect(function(input, gp)
    if gp then return end
    if input.KeyCode == Enum.KeyCode.C then
        controlsGui.Enabled = not controlsGui.Enabled
    end
end)
-- SUN GOD TITLE ──────────────────────────────────────────────────────────────────
local function createSunGodTitle(char)
    if titleBillboard then titleBillboard:Destroy() end
    local head = char:FindFirstChild("Head")
    if not head then return end
    local ad = Instance.new("BillboardGui")
    ad.Name = "SunGodTitle"
    ad.Adornee = head
    ad.Size = UDim2.new(8,0,2.5,0)
    ad.StudsOffset = Vector3.new(0,4,0)
    ad.AlwaysOnTop = true
    ad.LightInfluence = 0
    ad.MaxDistance = 2000
    ad.Parent = head
    local text = Instance.new("TextLabel", ad)
    text.Size = UDim2.new(1,0,1,0)
    text.BackgroundTransparency = 1
    text.Text = "Sun God"
    text.TextColor3 = Color3.fromRGB(255,215,0)
    text.TextStrokeColor3 = Color3.fromRGB(255,140,0)
    text.TextStrokeTransparency = 0.3
    text.Font = Enum.Font.Arcade
    text.TextSize = 72
    TweenService:Create(text, TweenInfo.new(1.8, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true), {
        TextTransparency = 0.15
    }):Play()
    titleBillboard = ad
end
-- SUN ORB (fixed close normal position) ─────────────────────────────────────────
local function createSunOrb(hrp)
    if not sunOrbEnabled then return end
    if sunOrb then sunOrb:Destroy() end
    if not hrp or not hrp.Parent then return end
    sunOrb = Instance.new("Part")
    sunOrb.Name = "SunOrb"
    sunOrb.Shape = Enum.PartType.Ball
    sunOrb.Size = Vector3.new(1,1,1)
    sunOrb.Color = SUN_COLOR
    sunOrb.Material = SUN_MATERIAL
    sunOrb.Anchored = true
    sunOrb.CanCollide = false
    sunOrb.Transparency = 0.2
    sunOrb.Position = hrp.Position + Vector3.new(0,-10,0)
    sunOrb.Parent = workspace
    local sunLight = Instance.new("PointLight", sunOrb)
    sunLight.Brightness = 4.5
    sunLight.Range = 28
    sunLight.Color = SUN_COLOR
    sunFireParticles = Instance.new("ParticleEmitter", sunOrb)
    sunFireParticles.Texture = SUN_FIRE_TEXTURE
    sunFireParticles.Color = ColorSequence.new{
        ColorSequenceKeypoint.new(0, Color3.fromRGB(255,255,0)),
        ColorSequenceKeypoint.new(0.4, Color3.fromRGB(255,220,80)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(255,60,0))
    }
    sunFireParticles.Size = NumberSequence.new{NumberSequenceKeypoint.new(0,2.4), NumberSequenceKeypoint.new(1,0.3)}
    sunFireParticles.Lifetime = NumberRange.new(0.9, 2.2)
    sunFireParticles.Rate = 160
    sunFireParticles.Speed = NumberRange.new(6,16)
    sunFireParticles.SpreadAngle = Vector2.new(360,360)
    sunFireParticles.RotSpeed = NumberRange.new(-180,180)
    sunFireParticles.LightEmission = 1
    sunFireParticles.Transparency = NumberSequence.new{NumberSequenceKeypoint.new(0,0.1), NumberSequenceKeypoint.new(1,1)}
    sunFireParticles.Enabled = true
    TweenService:Create(sunOrb, TweenInfo.new(SUN_SUMMON_TIME, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
        Size = Vector3.new(SUN_SIZE,SUN_SIZE,SUN_SIZE),
        Position = hrp.Position + hrp.CFrame.LookVector * -BEHIND_DISTANCE + Vector3.new(0,5,0)
    }):Play()
    task.delay(SUN_SUMMON_TIME - 0.2, function()
        if sunFireParticles and sunOrbEnabled then sunFireParticles:Emit(70) end
    end)
    if sunConnection then sunConnection:Disconnect() end
    sunConnection = RunService.Heartbeat:Connect(function()
        if not sunOrbEnabled or not sunOrb or not hrp or not hrp.Parent then return end
        local t = tick()
        local center = hrp.Position + Vector3.new(0, ORBIT_HEIGHT, 0)
        local targetOffset
        local pulse = 1 + (math.sin(t * PULSE_SPEED * math.pi * 2) * 0.5 + 0.5) * (PULSE_MAX - PULSE_MIN) * 0.5
        local aliveJitter = Vector3.new(
            math.noise(t*3.7)*0.6,
            math.noise(t*4.1)*0.8,
            math.noise(t*3.3)*0.6
        )
        if isCharging then
            -- Elliptical orbit during charge
            local angle = t * ORBIT_SPEED   -- still spins at same angular speed

            -- Parametric equations for ellipse (centered at geometric center)
            local x_ellipse = ORBIT_MAJOR_AXIS * math.cos(angle)
            local z_ellipse = ORBIT_MINOR_AXIS * math.sin(angle)

            -- Rotate the ellipse if you want it tilted
            local cosRot = math.cos(ELLIPSE_ROTATION)
            local sinRot = math.sin(ELLIPSE_ROTATION)
            local x_rot = x_ellipse * cosRot - z_ellipse * sinRot
            local z_rot = x_ellipse * sinRot + z_ellipse * cosRot

            -- Shift so one focus is near the player (Earth at focus, not center)
            local x = x_rot + FOCUS_OFFSET   -- push along major axis so closest point gets closer
            local z = z_rot

            local yBob = math.sin(t * ORBIT_BOB_FREQ * math.pi * 2) * ORBIT_BOB_AMP
            targetOffset = Vector3.new(x, yBob, z) + aliveJitter

            transitionStartTime = t
            wasChargingLastFrame = true
        else
            -- Normal behind position (close, follows facing)
            local behindDir = -hrp.CFrame.LookVector * BEHIND_DISTANCE
            local swayX = math.sin(t * SWAY_FREQ) * SWAY_AMP
            local swayZ = math.cos(t * SWAY_FREQ * 0.8) * SWAY_AMP * 0.7
            local bob = math.sin(t * SUN_BOB_FREQUENCY * math.pi * 2) * SUN_BOB_AMPLITUDE
            targetOffset = behindDir + Vector3.new(swayX, 10 + bob, swayZ) + aliveJitter
            -- Smooth transition back after charge
            if wasChargingLastFrame then
                local elapsed = t - transitionStartTime
                local alpha = math.clamp(elapsed / TRANSITION_TIME, 0, 1)
                if alpha < 1 then
                    local currentOffset = sunOrb.Position - center
                    targetOffset = currentOffset:Lerp(targetOffset, alpha^1.6)
                else
                    wasChargingLastFrame = false
                end
            end
        end
        local targetPos = center + targetOffset
        sunOrb.Position = sunOrb.Position:Lerp(targetPos, 0.14)
        local lookAt = center + Vector3.new(0, 2, 0)
        local baseCFrame = CFrame.lookAt(sunOrb.Position, lookAt)
        sunOrb.CFrame = baseCFrame * CFrame.Angles(0, t * SWAY_ROT_SPEED, math.sin(t*1.8)*0.12)
        local targetSize = Vector3.new(SUN_SIZE, SUN_SIZE, SUN_SIZE) * pulse
        sunOrb.Size = sunOrb.Size:Lerp(targetSize, 0.08)
    end)
end
-- HELPERS
local function updateDashGUI()
    dashFill:TweenSize(UDim2.new(dashCount/MAX_DASHES, 0, 1, 0), "Out", "Quad", 0.5, true)
end
local function updateChargeGUI()
    chargeFill:TweenSize(UDim2.new(isCharging and 1 or 0, 0, 1, 0), "Out", "Quad", 2, true)
end
local function loadAnim(humanoid, id, loop, priority)
    local anim = Instance.new("Animation")
    anim.AnimationId = id
    local track = humanoid:LoadAnimation(anim)
    track.Looped = loop or false
    track.Priority = priority or Enum.AnimationPriority.Action
    return track
end
local function playExclusive(track, fadeTime, speed)
    if not track then return end
    for _, t in pairs(tracks) do
        if t and t ~= track and t.Stop then
            pcall(t.Stop, t, fadeTime or 0.15)
        end
    end
    pcall(track.Play, track, fadeTime or 0.1, 1, speed or 1)
end
local function createDashTrail(hrp)
    local trail = Instance.new("Trail")
    local att0 = Instance.new("Attachment", hrp) att0.Position = Vector3.new(0,5,0)
    local att1 = Instance.new("Attachment", hrp) att1.Position = Vector3.new(0,-5,0)
    trail.Attachment0 = att0
    trail.Attachment1 = att1
    trail.Lifetime = 0.2
    trail.MinLength = 0.1
    trail.Transparency = NumberSequence.new{NumberSequenceKeypoint.new(0,0), NumberSequenceKeypoint.new(1,1)}
    trail.WidthScale = NumberSequence.new{NumberSequenceKeypoint.new(0,8), NumberSequenceKeypoint.new(1,0)}
    trail.Color = ColorSequence.new{
        ColorSequenceKeypoint.new(0, Color3.fromRGB(255,255,0)),
        ColorSequenceKeypoint.new(0.5, Color3.fromRGB(255,200,0)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(255,50,0))
    }
    trail.Parent = hrp
    task.delay(0.3, function() trail:Destroy() end)
end
local function dash(hrp, humanoid)
    if dashOnCooldown or dashCount <= 0 or isCharging then return false end
    dashOnCooldown = true
    dashCount -= 1
    updateDashGUI()
    isDashing = true
    if tracks.dash then tracks.dash:Play(0.1, 1, 1.2) end
    humanoid.AutoRotate = false
    local currentY = hrp.AssemblyLinearVelocity.Y
    local bv = Instance.new("BodyVelocity")
    bv.MaxForce = Vector3.new(1e5,1e5,1e5)
    bv.Velocity = hrp.CFrame.LookVector * DASH_FORCE + Vector3.new(0,currentY,0)
    bv.Parent = hrp
    if dashTrailEnabled then createDashTrail(hrp) end
    local sound = Instance.new("Sound")
    sound.SoundId = "rbxassetid://89341763232570"
    sound.Volume = 1
    sound.Parent = hrp
    sound:Play()
    sound.Ended:Once(function() if sound then sound:Destroy() end end)
    task.delay(5, function() if sound and sound.Parent then sound:Destroy() end end)
    task.delay(DASH_TIME, function()
        bv:Destroy()
        humanoid.AutoRotate = true
        isDashing = false
    end)
    task.delay(DASH_COOLDOWN, function() dashOnCooldown = false end)
    return true
end
local function punch(character)
    if punchOnCooldown then return end
    punchOnCooldown = true
    local hand = character:FindFirstChild("RightHand") or character:FindFirstChild("Right Arm")
    if not hand then task.delay(PUNCH_COOLDOWN, function() punchOnCooldown = false end) return end
    if tracks.punch then tracks.punch:Play(0.2, 1, LONG_PUNCH_SPEED) end
    local pe = Instance.new("ParticleEmitter", hand)
    pe.Texture = "rbxasset://textures/whiteCircle.png"
    pe.Color = ColorSequence.new{ColorSequenceKeypoint.new(0, Color3.fromRGB(255,200,0)), ColorSequenceKeypoint.new(1, Color3.fromRGB(255,0,0))}
    pe.Size = NumberSequence.new{NumberSequenceKeypoint.new(0,0.5), NumberSequenceKeypoint.new(0.5,1.2), NumberSequenceKeypoint.new(1,0)}
    pe.Lifetime = NumberRange.new(0.4,0.8)
    pe.Rate = 400
    pe.Speed = NumberRange.new(5,12)
    pe.SpreadAngle = Vector2.new(360,360)
    pe.RotSpeed = NumberRange.new(200,500)
    pe.LightEmission = 0.7
    pe.Transparency = NumberSequence.new{NumberSequenceKeypoint.new(0,0), NumberSequenceKeypoint.new(1,1)}
    task.delay(0.6, function() pe.Enabled = false task.delay(0.3, pe.Destroy, pe) end)
    task.delay(PUNCH_COOLDOWN, function() punchOnCooldown = false end)
end
-- CHARGE
local function createLightningBolt(parent)
    local att0 = Instance.new("Attachment", parent) att0.Position = Vector3.new(0,2,0)
    local att1 = Instance.new("Attachment", parent) att1.Position = Vector3.new(math.random(-8,8), math.random(-6,10), math.random(-8,8))
    local beam = Instance.new("Beam", parent)
    beam.Attachment0 = att0
    beam.Attachment1 = att1
    beam.Color = ColorSequence.new{ColorSequenceKeypoint.new(0,Color3.new(1,1,0)), ColorSequenceKeypoint.new(1,Color3.new(1,0.8,0))}
    beam.Width0 = 0.6
    beam.Width1 = 0.15
    beam.Transparency = NumberSequence.new(0.2)
    beam.LightEmission = 1
    beam.Texture = "rbxassetid://7158722143"
    beam.TextureSpeed = 5
    beam.TextureLength = 2
    beam.TextureMode = Enum.TextureMode.Stretch
    beam.CurveSize0 = math.random(-3,3)
    beam.CurveSize1 = math.random(-3,3)
    beam.FaceCamera = true
    return {beam=beam, att0=att0, att1=att1}
end
local function flickerLightning()
    task.spawn(function()
        while isCharging do
            for _, bolt in ipairs(lightningBeams) do
                if bolt.beam then
                    bolt.beam.Transparency = NumberSequence.new(math.random(10,40)/100)
                    bolt.att1.Position = Vector3.new(math.random(-8,8), math.random(-6,10), math.random(-8,8))
                    bolt.beam.CurveSize0 = math.random(-4,4)
                    bolt.beam.CurveSize1 = math.random(-4,4)
                end
            end
            task.wait(0.07)
        end
    end)
end
local function ringBurstLoop(emitter)
    task.spawn(function()
        while isCharging and emitter do
            emitter:Emit(1)
            task.wait(1.8)
        end
    end)
end
local function setupCharge(hrp)
    if chargeAttachment then return end
    chargeAttachment = Instance.new("Attachment", hrp)
    chargeAttachment.Position = Vector3.new(0,2,0)
    chargeSoundA = Instance.new("Sound", hrp)
    chargeSoundA.SoundId = CHARGE_LOOP_SOUND
    chargeSoundA.Looped = false
    chargeSoundA.Volume = 0
    chargeSoundB = chargeSoundA:Clone()
    chargeSoundB.Parent = hrp
    chargeParticles = Instance.new("ParticleEmitter", chargeAttachment)
    chargeParticles.Texture = "rbxasset://textures/particles/sparkles.png"
    chargeParticles.Color = ColorSequence.new(Color3.fromRGB(255,255,0))
    chargeParticles.Size = NumberSequence.new{NumberSequenceKeypoint.new(0,0.5), NumberSequenceKeypoint.new(0.5,1.5), NumberSequenceKeypoint.new(1,0)}
    chargeParticles.Lifetime = NumberRange.new(0.5,1.5)
    chargeParticles.Rate = 0
    chargeParticles.Speed = NumberRange.new(8,15)
    chargeParticles.SpreadAngle = Vector2.new(360,360)
    chargeParticles.RotSpeed = NumberRange.new(100,300)
    chargeParticles.LightEmission = 1
    chargeParticles.Transparency = NumberSequence.new{NumberSequenceKeypoint.new(0,0), NumberSequenceKeypoint.new(1,1)}
    chargeParticles.ZOffset = 2
    chargeRingParticles = Instance.new("ParticleEmitter", chargeAttachment)
    chargeRingParticles.Texture = "rbxasset://textures/whiteCircle.png"
    chargeRingParticles.Color = ColorSequence.new(Color3.fromRGB(255,255,255))
    chargeRingParticles.Size = NumberSequence.new{NumberSequenceKeypoint.new(0,0), NumberSequenceKeypoint.new(0.2,5), NumberSequenceKeypoint.new(1,10)}
    chargeRingParticles.Lifetime = NumberRange.new(1)
    chargeRingParticles.Rate = 0
    chargeRingParticles.Transparency = NumberSequence.new{NumberSequenceKeypoint.new(0,1), NumberSequenceKeypoint.new(0.2,0), NumberSequenceKeypoint.new(1,1)}
    chargeRingParticles.Orientation = Enum.ParticleOrientation.FacingCamera
    chargeYellowRingParticles = chargeRingParticles:Clone()
    chargeYellowRingParticles.Color = ColorSequence.new(Color3.fromRGB(255,255,0))
    chargeYellowRingParticles.Size = NumberSequence.new{NumberSequenceKeypoint.new(0,0), NumberSequenceKeypoint.new(0.3,4), NumberSequenceKeypoint.new(1,8)}
    chargeYellowRingParticles.Lifetime = NumberRange.new(0.8)
    chargeYellowRingParticles.Transparency = NumberSequence.new{NumberSequenceKeypoint.new(0,1), NumberSequenceKeypoint.new(0.3,0.2), NumberSequenceKeypoint.new(1,1)}
    chargeYellowRingParticles.Parent = chargeAttachment
    chargeCentralGlow = Instance.new("ParticleEmitter", chargeAttachment)
    chargeCentralGlow.Texture = "rbxasset://textures/whiteCircle.png"
    chargeCentralGlow.Color = ColorSequence.new{ColorSequenceKeypoint.new(0,Color3.fromRGB(255,255,0)), ColorSequenceKeypoint.new(1,Color3.fromRGB(255,200,0))}
    chargeCentralGlow.Size = NumberSequence.new{NumberSequenceKeypoint.new(0,2), NumberSequenceKeypoint.new(0.5,2.5), NumberSequenceKeypoint.new(1,2)}
    chargeCentralGlow.Lifetime = NumberRange.new(0.5)
    chargeCentralGlow.Rate = 0
    chargeCentralGlow.LightEmission = 1
    chargeCentralGlow.Transparency = NumberSequence.new{NumberSequenceKeypoint.new(0,0.5), NumberSequenceKeypoint.new(1,0.5)}
    for i = 1, 8 do
        table.insert(lightningBeams, createLightningBolt(hrp))
    end
end
local function startChargeSoundLoop()
    task.spawn(function()
        while isCharging do
            if chargeSoundA then chargeSoundA:Play() end
            task.wait(chargeLength - crossfadeTime)
            if not isCharging then break end
            if chargeSoundB then chargeSoundB:Play() end
            task.wait(chargeLength - crossfadeTime)
        end
    end)
end
local function toggleCharge(hrp)
    if not hrp then return end
    local char = hrp.Parent
    local humanoid = char and char:FindFirstChild("Humanoid")
    if not humanoid then return end
    setupCharge(hrp)
    isCharging = not isCharging
    if isCharging then
        originalWalkSpeed = humanoid.WalkSpeed
        originalAnchored = hrp.Anchored
        playExclusive(tracks.charge)
        chargeParticles.Enabled = true
        chargeRingParticles.Enabled = true
        chargeYellowRingParticles.Enabled = true
        chargeCentralGlow.Enabled = true
        for _, b in ipairs(lightningBeams) do if b.beam then b.beam.Enabled = true end end
        flickerLightning()
        ringBurstLoop(chargeRingParticles)
        ringBurstLoop(chargeYellowRingParticles)
        startChargeSoundLoop()
        if cameraShakeEnabled then
            if cameraShakeConnection then cameraShakeConnection:Disconnect() end
            cameraShakeConnection = RunService.RenderStepped:Connect(function()
                if not isCharging then return end
                local t = tick()
                local amt = 0.12
                local off = Vector3.new(math.sin(t*22)*amt, math.sin(t*27)*amt, math.sin(t*19)*amt)
                camera.CFrame *= CFrame.new(off)
            end)
        end
        local baseCFrame = hrp.CFrame
        humanoid.WalkSpeed = 0
        hrp.Anchored = true
        if charShakeEnabled then
            if characterShakeConnection then characterShakeConnection:Disconnect() end
            characterShakeConnection = RunService.RenderStepped:Connect(function()
                if not isCharging or not hrp then return end
                local t = tick()
                local amt = 0.1
                local off = Vector3.new(math.sin(t*20)*amt, math.sin(t*25)*amt, math.sin(t*22)*amt)
                hrp.CFrame = baseCFrame * CFrame.new(off)
            end)
        end
        local ti = TweenInfo.new(POWERUP_TIME, Enum.EasingStyle.Linear)
        TweenService:Create(chargeSoundA, ti, {Volume = 1}):Play()
        TweenService:Create(chargeSoundB, ti, {Volume = 1}):Play()
        TweenService:Create(chargeParticles, ti, {Rate = 1200}):Play()
        TweenService:Create(chargeCentralGlow, ti, {Rate = 10}):Play()
        if dashCount < MAX_DASHES and nextRechargeTime == math.huge then
            nextRechargeTime = tick() + rechargeInterval
        end
    else
        humanoid.WalkSpeed = originalWalkSpeed
        hrp.Anchored = originalAnchored
        if characterShakeConnection then characterShakeConnection:Disconnect() characterShakeConnection = nil end
        if cameraShakeConnection then cameraShakeConnection:Disconnect() cameraShakeConnection = nil end
        chargeParticles.Enabled = false
        chargeRingParticles.Enabled = false
        chargeYellowRingParticles.Enabled = false
        chargeCentralGlow.Enabled = false
        for _, b in ipairs(lightningBeams) do if b.beam then b.beam.Enabled = false end end
        chargeSoundA:Stop() chargeSoundA.Volume = 0
        chargeSoundB:Stop() chargeSoundB.Volume = 0
        if tracks.charge then pcall(tracks.charge.Stop, tracks.charge, 0.15) end
        playExclusive(tracks.idle)
        -- RETURN SOUND
        local returnSound = Instance.new("Sound")
        returnSound.SoundId = CHARGE_RETURN_SOUND
        returnSound.Volume = 0.7
        returnSound.Parent = hrp
        returnSound:Play()
        Debris:AddItem(returnSound, 4)
        task.delay(0.05, function()
            if humanoid then
                humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
                task.wait(0.03)
                humanoid:ChangeState(Enum.HumanoidStateType.Running)
            end
        end)
    end
    updateChargeGUI()
end
-- NO FALL DAMAGE
local function enableNoFallDamage(char)
    if noFallConnection then noFallConnection:Disconnect() end
    local humanoid = char:WaitForChild("Humanoid", 5)
    local root = char:WaitForChild("HumanoidRootPart", 5)
    if not humanoid or not root then return end
    noFallConnection = RunService.Heartbeat:Connect(function()
        if humanoid:GetState() == Enum.HumanoidStateType.Freefall
        or humanoid:GetState() == Enum.HumanoidStateType.FallingDown then
            local velY = root.AssemblyLinearVelocity.Y
            if velY < -80 then
                local capped = math.max(velY, -45)
                root.AssemblyLinearVelocity = Vector3.new(
                    root.AssemblyLinearVelocity.X, capped, root.AssemblyLinearVelocity.Z
                )
                if velY < -120 then
                    root:ApplyImpulse(Vector3.new(0, 800, 0))
                end
            end
        end
    end)
    local landedConn = humanoid.StateChanged:Connect(function(old, new)
        if new == Enum.HumanoidStateType.Landed
        and (old == Enum.HumanoidStateType.Freefall or old == Enum.HumanoidStateType.FallingDown) then
            if root.AssemblyLinearVelocity.Magnitude > 60 then
                task.delay(0.1, function()
                    if humanoid and humanoid.Parent then
                        humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
                        task.wait(0.05)
                        humanoid:ChangeState(Enum.HumanoidStateType.Running)
                    end
                end)
            end
        end
    end)
    char.AncestryChanged:Connect(function()
        if landedConn then landedConn:Disconnect() end
    end)
end
-- CHARACTER INIT
local function initCharacter(char)
    for _, conn in {runningConnection, noFallConnection, rechargeConnection, cameraShakeConnection, characterShakeConnection, jumpConnection, sunConnection} do
        if conn then conn:Disconnect() end
    end
    for _, t in pairs(tracks) do if t and t.Stop then pcall(t.Stop, t) end end
    tracks = {}
    isDashing = false
    isCharging = false
    dashCount = MAX_DASHES
    nextRechargeTime = math.huge
    if chargeAttachment then chargeAttachment:Destroy() chargeAttachment = nil end
    for _, b in ipairs(lightningBeams) do
        if b.att0 then b.att0:Destroy() end
        if b.att1 then b.att1:Destroy() end
        if b.beam then b.beam:Destroy() end
    end
    lightningBeams = {}
    if sunOrb then sunOrb:Destroy() sunOrb = nil end
    updateDashGUI()
    updateChargeGUI()
    local humanoid = char:WaitForChild("Humanoid", 8)
    local hrp = char:WaitForChild("HumanoidRootPart", 8)
    if not humanoid or not hrp then return end
    tracks.idle = loadAnim(humanoid, ANIMATIONS.idle, true)
    tracks.walk = loadAnim(humanoid, ANIMATIONS.walk, true)
    tracks.jump = loadAnim(humanoid, ANIMATIONS.jump, false)
    tracks.dash = loadAnim(humanoid, ANIMATIONS.dash, false, Enum.AnimationPriority.Action4)
    tracks.punch = loadAnim(humanoid, ANIMATIONS.punch, false, Enum.AnimationPriority.Action4)
    tracks.charge = loadAnim(humanoid, ANIMATIONS.charge, true, Enum.AnimationPriority.Action4)
    if tracks.idle then tracks.idle:Play() end
    runningConnection = humanoid.Running:Connect(function(speed)
        if isDashing or isCharging then return end
        if speed > 0.1 then
            playExclusive(tracks.walk, 0.2, WALK_PLAY_SPEED)
        else
            playExclusive(tracks.idle)
        end
    end)
    jumpConnection = humanoid.StateChanged:Connect(function(_, new)
        if new == Enum.HumanoidStateType.Jumping and not isDashing and not isCharging then
            playExclusive(tracks.jump, 0.1, 1)
        end
    end)
    rechargeConnection = RunService.Heartbeat:Connect(function()
        if isCharging and dashCount < MAX_DASHES and tick() >= nextRechargeTime then
            dashCount = math.min(dashCount + 1, MAX_DASHES)
            updateDashGUI()
            nextRechargeTime = tick() + rechargeInterval
        end
    end)
    enableNoFallDamage(char)
    createSunGodTitle(char)
    task.delay(0.4, function()
        if hrp and hrp.Parent then createSunOrb(hrp) end
    end)
end
-- START
local char = lp.Character or lp.CharacterAdded:Wait()
initCharacter(char)
lp.CharacterAdded:Connect(initCharacter)
-- INPUT
UserInputService.InputBegan:Connect(function(input, gp)
    if gp then return end
    local char = lp.Character
    if not char then return end
    local humanoid = char:FindFirstChild("Humanoid")
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not humanoid or not hrp then return end
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        if isCharging then return end
        local didDash = dash(hrp, humanoid)
        if didDash then punch(char) end
    end
    if input.KeyCode == Enum.KeyCode.Z then
        toggleCharge(hrp)
    end
end)
